# PA1 最简单的计算机

## Questions
1. **程序 1+2+3+...+100 的状态机**
> 这个程序需要更新的状态有 PC 和  r1, r2 寄存器，用一个三元组（PC, r1, r2)表示程序的所有状态。初始状态是（0, x, x) x 表示未初始化。 程序PC = 0 处的指令是 mov r1, 0 执行完后 PC 会指向下一条指令，因此下一个状态是(1, 0, x) 以此类推状态转换过程如下：
（0, x, x) -> (1, 0, x) -> (2, 0, 0) -> (3, 0, 1) -> (4, 1, 1) -> (5, 1, 2) -> (6, 3, 2) -> (7, 3, 3) -> (8, 6, 3) -> (9, 6, 4) -> (10, 10, 4) ... 
首先将 r1, r2 寄存器初始化， 然后每次输入一个加数到 r2，再求和，求和的结果放在 r1 寄存器中。

2. **为什么 init_monitor() 函数的代码都是函数调用**
- **初始化顺序和依赖管理**
init() 是在系统或模块启动时调用的，用于执行一些必要的初始化操作，将初始化操作封装在init() 函数中可以确保这些操作在启动时按顺序执行，并可以方便的管理依赖关系。
- **避免代码沉余和复杂性**
若实现在init() 中则会导致函数体非常庞大和复杂，难以维护和调试。
3. ** 什么是匿名 Union**
匿名 Union 是没有名称和声明类表的 union， 匿名 union 仅仅通知编译器它的成员变量共享一个地址，而变量本身是直接引用的，不使用通常的点号运算符语法。
- *特点*： 不能包含受保护的成员或私有成员，不能定义成员函数， 所有成员必须是公有的，在全局作用域或命名空间中定义的匿名Union必须声明为static，否则必须放在匿名名字空间。
           
4. **在 cmd_c() 函数中，调用 cpu_exec() 的时候传入了参数 -1,这代表着什么**
参数 n 的类型为 uint64_t 是无符号的整数，当传入参数为 -1 时 n 为一个非常大的值（2^64 - 1）,此时如果函数内部没有任何限制措施的话就会有执行大量的指令，可能会导致模拟器运行很长时间，消耗大量的cpu, 内存等资源。
```
void cpu_exec(uint64_t n) {
  ...
  execute(n);
  ...
}

static void execute(uint64_t n) {
  Decode s;
  for (;n > 0; n --) {
    exec_once(&s, cpu.pc);   // 用于执行一条指令
    g_nr_guest_inst ++;      // 用于记录模拟器执行的指令数。
    trace_and_difftest(&s, cpu.pc);  //用于跟踪指令执行情况
    if (nemu_state.state != NEMU_RUNNING) break;
    IFDEF(CONFIG_DEVICE, device_update());  //用于更新模拟器中的设备状态。
  }
}
此时会在 for 循环中执行大量代码
```
 

5. **未定义行为** 在 c99 中，"未定义行为" 是指程序在使用非移植或错误的程序构造数据时，国际标准并未对其提出任何要求的行为。这意味着程序出现未定义行为时，其具体结果是不可预测的，可能导致程序崩溃，数据损坏，安全漏洞，甚至可能看似正常运行。 
以下是常见的易导致未定义行为的情况：
- 对指针进行未初始化的解引用
- 数组越界访问
- 除以零
- 指针运算超出数组边界

6. **修复quit**
在 quit 时设置状态
```
static int cmd_q(char *args) {
  nemu_state.state = NEMU_QUIT;
  return -1;
}
```


